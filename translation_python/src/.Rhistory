Load.Task[Load.Task <=0]<-NA
MAT<-matrix(0, length(Load.Task),length(Indiv))
rownames(MAT)<-1:length(Load.Task)
colnames(MAT)<-which(ColSum-colSums(netMax)>0)
MAT2<-MAT
for (i in 1:length(Indiv)){
MAT[,i]<-Load.Indiv[i]
MAT2[,i]<-Load.Indiv[i]-Load.Task
}
tmp<-which(abs(MAT2)==min(abs(MAT2),na.rm=T),arr.ind=TRUE)[1,]
if(MAT2[tmp[1],tmp[2]]<0)
netMax[tmp[1], Indiv[tmp[2]]]<-Load.Indiv[tmp[2]]
if(MAT2[tmp[1],tmp[2]]>=0)
netMax[tmp[1], Indiv[tmp[2]]]<-Load.Task[tmp[1]]
}
return(netMax)
}
# now making the dataframe
# now making the dataframe
for(testNumber in 1:length(testFolders))
{
testFolderName = testFolders[testNumber];
testFolderPath = paste(outputDirectory,"/",testFolderName,sep="");
# Check if the file already exists
testFiles = list.files(path = testFolderPath);
if(any(testFiles=="H2_data.csv") & !overwriteFiles)
{
cat("H2/Qnorm computation for test ",testFolderName," is already done. Proceeding to next test.\n",sep="");
next;
}
cat("Starting H2/Qnorm assessment for test : ",testFolderName,".\n",sep="");
# Initialize the output : one value of H2 per bout.
output = data.frame(arrayNumber = rep(c(1:numberOfArrays),each=numberOfBouts*numberOfSimulations),
simulation = rep(c(1:numberOfSimulations),times=numberOfArrays,each=numberOfBouts),
bout = rep(c(1:numberOfBouts),times=numberOfArrays*numberOfSimulations),
H2 = 0,
Q = 0,
Qnorm = 0)
i = 0;
for(arrayNumber in 1:numberOfArrays)
{
arrayFolder = paste(testFolderPath,"/Array",sprintf("%02d",arrayNumber-1),sep="");
bla = read.csv(paste(arrayFolder,"/array_info.csv",sep=""))
numberOfResources = bla$number_of_flowers;
# Import the visitation sequences of this array
matrixOfVisitationSequences = as.matrix(unname(read.csv(paste(arrayFolder,"/matrix_of_visitation_sequences.csv",sep=""),header=F)));
matrixOfVisitationSequences = matrixOfVisitationSequences + 1
for(sim in 1:numberOfSimulations)
{
# Isolate the visit sequences of the sim
simVS = subset(matrixOfVisitationSequences,matrixOfVisitationSequences[,1]==sim);
for(bout in 1:numberOfBouts)
{
i = i + 1;
# Isolate the visit sequences of the bout
boutVS = subset(simVS,simVS[,2]==bout);
# Remove all 0 and 3 first columns.
boutLength = apply(boutVS,2,sum); # Summing both lines. To get longest seq, we retrieve values > 0 (Smart).
boutVS = boutVS[,boutLength>0];
boutVS = boutVS[,-c(1:3)];
# Count all visits
flowerVisited = apply(boutVS,1,count);
# Initialize the matrix at the correct format to be passed through the H2 assessment function.
H2mat = matrix(0,nrow=numberOfResources,ncol=numberOfBees);
# Fill the matrix with the counts
for(bee in 1:numberOfBees)
{
visitCount = flowerVisited[[bee]];
visitCount = visitCount[which(visitCount$x!=1 & visitCount$x!=0),];
for(flower in visitCount$x)
{
H2mat[flower-1,bee] = visitCount[which(visitCount$x==flower),2];
}
}
# H2 computation
H2_fun_result = H2fun(H2mat,H2_integer = T);
output$H2[i] = H2_fun_result[1];
if (is.nan(output$H2[i])) output$H2[i] = H2_fun_result[2]
# Qnorm computation
output$Q[i] = DIRT_LPA_wb_plus(H2mat)$modularity
output$Qnorm[i] = DIRT_LPA_wb_plus(H2mat)$modularity / DIRT_LPA_wb_plus(optim_matrix_bip(H2mat))$modularity
# Added part for Different Experience Sims. If no vector used by 2nd bee, H2 is 1.
if(any(apply(H2mat,2,sum)==0)) { output[i,"H2"] = 1; output[i,"Q"] = 1; output[i,"Qnorm"] = 1}
}
}
}
write.csv2(output,paste(testFolderPath,"/H2_data.csv",sep=""),row.names=F)
}
# now making the dataframe
for(testNumber in 1:length(testFolders))
{
testFolderName = testFolders[testNumber];
testFolderPath = paste(outputDirectory,"/",testFolderName,sep="");
# Check if the file already exists
testFiles = list.files(path = testFolderPath);
if(any(testFiles=="H2_data.csv") & !overwriteFiles)
{
cat("H2/Qnorm computation for test ",testFolderName," is already done. Proceeding to next test.\n",sep="");
next;
}
cat("Starting H2/Qnorm assessment for test : ",testFolderName,".\n",sep="");
# Initialize the output : one value of H2 per bout.
output = data.frame(arrayNumber = rep(c(1:numberOfArrays),each=numberOfBouts*numberOfSimulations),
simulation = rep(c(1:numberOfSimulations),times=numberOfArrays,each=numberOfBouts),
bout = rep(c(1:numberOfBouts),times=numberOfArrays*numberOfSimulations),
H2 = 0,
Q = 0,
Qnorm = 0)
i = 0;
for(arrayNumber in 1:numberOfArrays)
{
arrayFolder = paste(testFolderPath,"/Array",sprintf("%02d",arrayNumber-1),sep="");
beeInfos = read.csv(paste(testFolderPath,"/Array00/bee_info.csv",sep=""));
arrayID = beeInfos[1,"array_ID"];
arrayInfos = read.csv(paste(arraysDirectory,"/",arrayID,"/array_info.csv",sep=""))
numberOfResources = arrayInfos$number_of_flowers;
# Import the visitation sequences of this array
matrixOfVisitationSequences = as.matrix(unname(read.csv(paste(arrayFolder,"/matrix_of_visitation_sequences.csv",sep=""),header=F)));
matrixOfVisitationSequences = matrixOfVisitationSequences + 1
for(sim in 1:numberOfSimulations)
{
# Isolate the visit sequences of the sim
simVS = subset(matrixOfVisitationSequences,matrixOfVisitationSequences[,1]==sim);
for(bout in 1:numberOfBouts)
{
i = i + 1;
# Isolate the visit sequences of the bout
boutVS = subset(simVS,simVS[,2]==bout);
# Remove all 0 and 3 first columns.
boutLength = apply(boutVS,2,sum); # Summing both lines. To get longest seq, we retrieve values > 0 (Smart).
boutVS = boutVS[,boutLength>0];
boutVS = boutVS[,-c(1:3)];
# Count all visits
flowerVisited = apply(boutVS,1,count);
# Initialize the matrix at the correct format to be passed through the H2 assessment function.
H2mat = matrix(0,nrow=numberOfResources,ncol=numberOfBees);
# Fill the matrix with the counts
for(bee in 1:numberOfBees)
{
visitCount = flowerVisited[[bee]];
visitCount = visitCount[which(visitCount$x!=1 & visitCount$x!=0),];
for(flower in visitCount$x)
{
H2mat[flower-1,bee] = visitCount[which(visitCount$x==flower),2];
}
}
# H2 computation
H2_fun_result = H2fun(H2mat,H2_integer = T);
output$H2[i] = H2_fun_result[1];
if (is.nan(output$H2[i])) output$H2[i] = H2_fun_result[2]
# Qnorm computation
output$Q[i] = DIRT_LPA_wb_plus(H2mat)$modularity
output$Qnorm[i] = DIRT_LPA_wb_plus(H2mat)$modularity / DIRT_LPA_wb_plus(optim_matrix_bip(H2mat))$modularity
# Added part for Different Experience Sims. If no vector used by 2nd bee, H2 is 1.
if(any(apply(H2mat,2,sum)==0)) { output[i,"H2"] = 1; output[i,"Q"] = 1; output[i,"Qnorm"] = 1}
}
}
}
write.csv2(output,paste(testFolderPath,"/H2_data.csv",sep=""),row.names=F)
}
# Join the files
H2Vector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts)
QVector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts)
QnormVector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts)
lineH2 = 1;
for(testNumber in 1:length(testFolders))
{
folderName = testFolders[testNumber];
cat("Importing data from :",folderName,"\n");
fileDirectory = paste(outputDirectory,"/",folderName,sep="");
## Import H2
H2Data = read.csv2(paste(fileDirectory,"/H2_data.csv",sep=""));
colnames(H2Data) = c("arrayNumber","simulation","bout","H2","Q","Qnorm");
extractH2 = H2Data$H2;
extractQ = H2Data$Q;
extractQnorm = H2Data$Qnorm;
dataLength = length(extractH2);
H2Vector[c(lineH2:(lineH2+dataLength-1))] = extractH2;
QVector[c(lineH2:(lineH2+dataLength-1))] = extractQ;
QnormVector[c(lineH2:(lineH2+dataLength-1))] = extractQnorm;
lineH2 = lineH2 + dataLength;
}
H2Data = cbind(outputData[which(outputData$bee==1),],H2 = H2Vector,Q = QVector, Qnorm = QnormVector);
write.csv(H2Data,paste(outputDirectory,"/H2_data.csv",sep=""),row.names = F)
############# FOR THE ANALYSIS OF THE PYTHON OUTPUTS
library(plyr) # count
library(rstudioapi) # getActiveDocumentContext
library(RColorBrewer) # colorRampPalette
library(bipartite) # H2fun, DIRT_LPA_wb_plus
library(beepr) # beep
library(MASS) # ?
library(Rcpp) # sourceCpp
library(lme4) # glmer
library(emmeans) # lstrends
library(ggplot2)
library(ggthemes)
library(gtable)
library(grid)
library(gridExtra)
library(tibble)
library(car)
library(ggpubr)
rm(list=ls());
currentPath = getActiveDocumentContext()$path
setwd(dirname(currentPath))
# Functions & Sourcing ----------------------------------------------------
SinkGLMEROutput = function(name,testOutput,path,hoc=NULL)
{
file.create(paste(path,"/",name,".txt",sep=""))
sink(paste(path,"/",name,".txt",sep=""))
print(summary(testOutput))
cat("\n\n")
print(anova(testOutput))
cat("\n\n")
if(!is.null(hoc)) print(hoc);
sink(NULL)
}
source("01-Functions.R")
# Parameters --------------------------------------------------------------
# Simulation specifications
numberOfArrays = 1;
numberOfSimulations = 100;
numberOfBouts = 30;
numberOfBees = 2;
arrayOfTest = c("generate")
overwriteFiles = TRUE;
makeFilm = FALSE; # Create a 2D density plot for each array and all arrays combined
# SubSeqSimilarity specific parameters
iter = 100;
subSeqSize = 3;
stopAfterTrapline = F;
# Root Code (Run before any part) -----------------------------------------
# Get to the specified path and retrieve the file in this folder.
currentDirectory = getwd()
outputDirectory = paste(currentDirectory,"/Output",sep="");
arraysDirectory = paste(currentDirectory,"/Arrays",sep="");
testFolders = list.files(path=outputDirectory);
# By default we retrieve files that contain the "generate" word.
testFolders = testFolders[CharacterMatch(testFolders,"generate")];
if (length(testFolders)==0) {testFolders=c("")}
numberOfTests = length(testFolders);
# Initialize output dataframe
arrayTypesOnData = c();
learningFactors = c();
abandonFactors = c();
routeCompares = c();
for(fld in testFolders)
{
beeInfos = read.csv(paste(outputDirectory,"/",fld,"/Array00/bee_info.csv",sep=""))
arrayID = beeInfos[1,"array_ID"];
arrayFolder = paste(arraysDirectory,"/",arrayID,sep="");
arrayInfos = read.csv(paste(arrayFolder,"/array_info.csv",sep=""))
beeInfos = read.csv(paste(outputDirectory,"/",fld,"/Array00/bee_info.csv",sep=""))
learningFactors = c(learningFactors,beeInfos$learning_facto[1]);
abandonFactors = c(abandonFactors,beeInfos$abandon_factor[1]);
if(beeInfos$use_route_compare[1]) routeCompares = c(routeCompares,"routeCompare") else routeCompares = c(routeCompares,"noRouteCompare");
arrayNameChr = paste("R",arrayInfos$numberOfResources,"-P",arrayInfos$numberOfPatches,sep="")
if(!is.na(arrayInfos$flowers_per_patch)) {arrayNameChr = paste(arrayNameChr,"-",arrayInfos$flowers_per_patch,sep="")}
arrayTypesOnData = c(arrayTypesOnData,arrayNameChr)
}
numberOfArrayTypes = length(arrayTypesOnData)
outputData = data.frame(arrayType = rep(arrayTypesOnData,each=(numberOfTests/numberOfArrayTypes)*numberOfArrays*numberOfSimulations*numberOfBouts*numberOfBees),
algorithm = rep(routeCompares,each=numberOfArrays*numberOfSimulations*numberOfBouts*numberOfBees),
learningValue = rep(learningFactors,each=numberOfArrays*numberOfSimulations*numberOfBouts*numberOfBees),
abandonValue = rep(abandonFactors,each=numberOfArrays*numberOfSimulations*numberOfBouts*numberOfBees),
arrayNumber = rep(c(1:numberOfArrays),each=numberOfSimulations*numberOfBouts*numberOfBees,times=numberOfTests),
simulation = rep(c(1:numberOfSimulations),each=numberOfBouts*numberOfBees,times=numberOfTests*numberOfArrays),
bout = rep(c(1:numberOfBouts),each=numberOfBees,times=numberOfTests*numberOfArrays*numberOfSimulations),
bee = rep(c(1:numberOfBees),times=numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts),
stringsAsFactors = F);
for(testNumber in 1:length(testFolders))
{
testFolderName = testFolders[testNumber];
testFolderPath = paste(outputDirectory,"/",testFolderName,sep="");
}
##################### group route quality data #############################
for(testNumber in 1:length(testFolders))
{
testFolderName = testFolders[testNumber]; # fileName
testFolderPath = paste(outputDirectory,"/",testFolderName,sep=""); # fileDirectory
# Check if the file already exists
testFiles = list.files(path = testFolderPath);
if(any(testFiles=="group_quality_data.csv") & !overwriteFiles)
{
cat("Group quality computation for test ",testFolderName," is already done. Proceeding to next test.\n",sep="");
next;
}
cat("Starting group quality assessment for test : ",testFolderName,".\n",sep="");
beeInfos = read.csv(paste(testFolderPath,"/Array00/bee_info.csv",sep=""));
arrayType = beeInfos[1,"array_ID"];
arrayFolder = paste(arraysDirectory,"/",arrayType,sep="");
arrayInfos = read.csv(paste(arrayFolder,"/array_info.csv",sep=""))
n=nchar(arrayType)
arrayType=substring(arrayType,1,n-3)
arrayFiles = list.files(testFolderPath);
arrayFiles = arrayFiles[CharacterMatch(arrayFiles,"Array")];
allQualityData = data.frame();
for(arrayNumber in 1:length(arrayFiles))
{
arrayName = paste(arrayType,sprintf("%02d",arrayNumber-1),sep="_");
arrayFolder = paste(getwd(),"/Arrays/",arrayName,sep="");
optimalRoute2Ind = read.csv(paste(arrayFolder,"optimal_route_2_ind.csv",sep="/"));
arrayGeometry = read.csv2(paste(arrayFolder,"/array_geometry.csv",sep=""));
optimalQuality2Ind = as.double(optimalRoute2Ind);
qualityFolder = paste(testFolderPath,"/Array",sprintf("%02d",arrayNumber-1),sep="");
if(any(list.files(qualityFolder)=="route_quality_DF.csv"))
{
routeQualityDF = read.csv(paste(qualityFolder,"/route_quality_DF.csv",sep=""));
# output : ArrayNumber, Simulation, Bout, Q1, Q2, Qall, QallRelative, Rank
routeQualityData = data.frame()
for(sim in 1:numberOfSimulations)
{
for(b in 1:numberOfBouts)
{
indData = subset(routeQualityDF,simulation==sim-1 & bout==b-1)
newLine = data.frame(ArrayNumber=arrayNumber,
Simulation=sim,
Bout=b,
Q1=indData$absolute_quality[1],
Q2=indData$absolute_quality[2])
routeQualityData = rbind(routeQualityData,newLine)
}
}
groupQuality = routeQualityData$Q1+routeQualityData$Q2
routeQualityData$Qall = round(groupQuality,3);
routeQualityData$QallRelative = routeQualityData$Qall/optimalQuality2Ind;
write.csv(routeQualityData,paste(qualityFolder,"/route_quality_data.csv",sep=""),row.names=F);
file.remove(paste(qualityFolder,"/route_quality_DF.csv",sep=""))
}
routeQualityData = read.csv(paste(qualityFolder,"/route_quality_data.csv",sep=""))
allQualityData = rbind(allQualityData,routeQualityData);
}
write.csv(allQualityData,paste(testFolderPath,"/group_quality_data.csv",sep=""),row.names = F);
}
# Join the files
groupQualityVector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts);
Q1Vector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts);
Q2Vector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts);
lineGroupQuality = 1;
for(testNumber in 1:length(testFolders))
{
folderName = testFolders[testNumber];
fileDirectory = paste(outputDirectory,"/",folderName,sep="");
## Import Group Quality
groupQuality = read.csv(paste(fileDirectory,"/group_quality_data.csv",sep=""));
extractGroupQuality = groupQuality$QallRelative;
extractQ1 = groupQuality$Q1;
extractQ2 = groupQuality$Q2;
dataLength = length(extractGroupQuality);
groupQualityVector[c(lineGroupQuality:(lineGroupQuality+dataLength-1))] = extractGroupQuality;
Q1Vector[c(lineGroupQuality:(lineGroupQuality+dataLength-1))] = extractQ1;
Q2Vector[c(lineGroupQuality:(lineGroupQuality+dataLength-1))] = extractQ2;
lineGroupQuality = lineGroupQuality + dataLength;
}
### Output GroupQuality
groupQualityData = cbind(outputData[which(outputData$bee==1),],
Q1 = Q1Vector,
Q2 = Q2Vector,
groupQuality = groupQualityVector);
write.csv(groupQualityData,paste(outputDirectory,"/group_quality_data.csv",sep=""),row.names = F)
#group quality
data=read.csv(paste(outputDirectory,"/group_quality_data.csv",sep=""))
modelVector=rep('None',nrow(data))
modelVector[data$learningValue==1.5 & data$abandonValue==1.]="model 1"
modelVector[data$learningValue==1. & data$abandonValue==0.75]="model 2"
modelVector[data$learningValue==1.5 & data$abandonValue==0.75]="model 3"
data["model"]=modelVector
nArrayTypes=length(levels(as.factor(data$arrayType)))
data=aggregate(data,list(data$arrayType,data$model,data$bout),mean)
colnames(data)[2]="Model"
ggplot(data = data,aes(x=bout, y=groupQuality,group=Model,color=Model)) +
geom_line()+
facet_wrap(~Group.1)+
ylim(0,1)
################Qnorm#########################
#bipartite function to compute the optimal Qnorm, from the paper
# "Pasquaretta C, Jeanson R. Division of labor as a bipartite network. Behav Ecol. 2018;29(2): 342-352."
optim_matrix_bip <-function (net){
ColSum<-sort(colSums(net),decreasing=T)
RowSum<-sort(rowSums(net),decreasing=T)
netMax<-matrix(0,nrow(net),ncol(net))
while(sum(netMax)!=sum(net)){
Indiv <-which(ColSum-colSums(netMax)>0)
Load.Indiv <-(ColSum-colSums(netMax))[ColSum-colSums(netMax)>0]
Load.Task <-sort(rowSums(net), decreasing =T)-(rowSums(netMax))
Load.Task[Load.Task <=0]<-NA
MAT<-matrix(0, length(Load.Task),length(Indiv))
rownames(MAT)<-1:length(Load.Task)
colnames(MAT)<-which(ColSum-colSums(netMax)>0)
MAT2<-MAT
for (i in 1:length(Indiv)){
MAT[,i]<-Load.Indiv[i]
MAT2[,i]<-Load.Indiv[i]-Load.Task
}
tmp<-which(abs(MAT2)==min(abs(MAT2),na.rm=T),arr.ind=TRUE)[1,]
if(MAT2[tmp[1],tmp[2]]<0)
netMax[tmp[1], Indiv[tmp[2]]]<-Load.Indiv[tmp[2]]
if(MAT2[tmp[1],tmp[2]]>=0)
netMax[tmp[1], Indiv[tmp[2]]]<-Load.Task[tmp[1]]
}
return(netMax)
}
# now making the dataframe
for(testNumber in 1:length(testFolders))
{
testFolderName = testFolders[testNumber];
testFolderPath = paste(outputDirectory,"/",testFolderName,sep="");
# Check if the file already exists
testFiles = list.files(path = testFolderPath);
if(any(testFiles=="H2_data.csv") & !overwriteFiles)
{
cat("H2/Qnorm computation for test ",testFolderName," is already done. Proceeding to next test.\n",sep="");
next;
}
cat("Starting H2/Qnorm assessment for test : ",testFolderName,".\n",sep="");
# Initialize the output : one value of H2 per bout.
output = data.frame(arrayNumber = rep(c(1:numberOfArrays),each=numberOfBouts*numberOfSimulations),
simulation = rep(c(1:numberOfSimulations),times=numberOfArrays,each=numberOfBouts),
bout = rep(c(1:numberOfBouts),times=numberOfArrays*numberOfSimulations),
H2 = 0,
Q = 0,
Qnorm = 0)
i = 0;
for(arrayNumber in 1:numberOfArrays)
{
arrayFolder = paste(testFolderPath,"/Array",sprintf("%02d",arrayNumber-1),sep="");
beeInfos = read.csv(paste(testFolderPath,"/Array00/bee_info.csv",sep=""));
arrayID = beeInfos[1,"array_ID"];
arrayInfos = read.csv(paste(arraysDirectory,"/",arrayID,"/array_info.csv",sep=""))
numberOfResources = arrayInfos$number_of_flowers;
# Import the visitation sequences of this array
matrixOfVisitationSequences = as.matrix(unname(read.csv(paste(arrayFolder,"/matrix_of_visitation_sequences.csv",sep=""),header=F)));
matrixOfVisitationSequences = matrixOfVisitationSequences + 1
for(sim in 1:numberOfSimulations)
{
# Isolate the visit sequences of the sim
simVS = subset(matrixOfVisitationSequences,matrixOfVisitationSequences[,1]==sim);
for(bout in 1:numberOfBouts)
{
i = i + 1;
# Isolate the visit sequences of the bout
boutVS = subset(simVS,simVS[,2]==bout);
# Remove all 0 and 3 first columns.
boutLength = apply(boutVS,2,sum); # Summing both lines. To get longest seq, we retrieve values > 0 (Smart).
boutVS = boutVS[,boutLength>0];
boutVS = boutVS[,-c(1:3)];
# Count all visits
flowerVisited = apply(boutVS,1,count);
# Initialize the matrix at the correct format to be passed through the H2 assessment function.
H2mat = matrix(0,nrow=numberOfResources,ncol=numberOfBees);
# Fill the matrix with the counts
for(bee in 1:numberOfBees)
{
visitCount = flowerVisited[[bee]];
visitCount = visitCount[which(visitCount$x!=1 & visitCount$x!=0),];
for(flower in visitCount$x)
{
H2mat[flower-1,bee] = visitCount[which(visitCount$x==flower),2];
}
}
# H2 computation
H2_fun_result = H2fun(H2mat,H2_integer = T);
output$H2[i] = H2_fun_result[1];
if (is.nan(output$H2[i])) output$H2[i] = H2_fun_result[2]
# Qnorm computation
output$Q[i] = DIRT_LPA_wb_plus(H2mat)$modularity
output$Qnorm[i] = DIRT_LPA_wb_plus(H2mat)$modularity / DIRT_LPA_wb_plus(optim_matrix_bip(H2mat))$modularity
# Added part for Different Experience Sims. If no vector used by 2nd bee, H2 is 1.
if(any(apply(H2mat,2,sum)==0)) { output[i,"H2"] = 1; output[i,"Q"] = 1; output[i,"Qnorm"] = 1}
}
}
}
write.csv2(output,paste(testFolderPath,"/H2_data.csv",sep=""),row.names=F)
}
# Join the files
H2Vector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts)
QVector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts)
QnormVector = numeric(numberOfTests*numberOfArrays*numberOfSimulations*numberOfBouts)
lineH2 = 1;
for(testNumber in 1:length(testFolders))
{
folderName = testFolders[testNumber];
cat("Importing data from :",folderName,"\n");
fileDirectory = paste(outputDirectory,"/",folderName,sep="");
## Import H2
H2Data = read.csv2(paste(fileDirectory,"/H2_data.csv",sep=""));
colnames(H2Data) = c("arrayNumber","simulation","bout","H2","Q","Qnorm");
extractH2 = H2Data$H2;
extractQ = H2Data$Q;
extractQnorm = H2Data$Qnorm;
dataLength = length(extractH2);
H2Vector[c(lineH2:(lineH2+dataLength-1))] = extractH2;
QVector[c(lineH2:(lineH2+dataLength-1))] = extractQ;
QnormVector[c(lineH2:(lineH2+dataLength-1))] = extractQnorm;
lineH2 = lineH2 + dataLength;
}
H2Data = cbind(outputData[which(outputData$bee==1),],H2 = H2Vector,Q = QVector, Qnorm = QnormVector);
write.csv(H2Data,paste(outputDirectory,"/H2_data.csv",sep=""),row.names = F)
#Qnorm
data=read.csv(paste(outputDirectory,"/H2_data.csv",sep=""))
modelVector=rep('None',nrow(data))
modelVector[data$learningValue==1.5 & data$abandonValue==1.]="model 1"
modelVector[data$learningValue==1. & data$abandonValue==0.75]="model 2"
modelVector[data$learningValue==1.5 & data$abandonValue==0.75]="model 3"
data["model"]=modelVector
nArrayTypes=length(levels(as.factor(data$arrayType)))
data=aggregate(data,list(data$arrayType,data$model,data$bout),mean)
colnames(data)[2]="Model"
ggplot(data = data,aes(x=bout, y=Qnorm,group=Model,color=Model)) +
geom_line()+
facet_wrap(~Group.1)+
ylim(0,1)
